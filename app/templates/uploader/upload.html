{% extends "base.html" %}

{% block content %}
<link rel="stylesheet" href="{{ url_for('static', path='css/custom-dropdown.css') }}">
<div class="container">
    <div class="upload-page">
        <div class="page-header">
            <h2>üì§ Upload Game</h2>
            <p class="page-subtitle">Upload a new game to the repository</p>
            <div class="alternative-upload">
                <a href="https://swdld.obnoxious.lol/uploadercp/upload" target="_blank" class="btn-alt-upload">
                    üöÄ Use Alternative Upload (Bypasses Cloudflare Limit)
                </a>
                <small class="alt-upload-help">For files larger than 100MB, use the alternative uploader which has no file size restrictions.</small>
            </div>
        </div>

        <div class="upload-form-container">
            <form id="uploadForm" enctype="multipart/form-data">
                <div class="form-section">
                    <h3>Game Information</h3>

                    <div class="form-group">
                        <label for="type">Upload Type *</label>
                        <select id="type" name="type" required>
                            <option value="">Select type...</option>
                            <option value="filepath">File Upload</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="directory_id">Upload Directory <abbr title="required" aria-label="required">*</abbr></label>
                        <select id="directory_id" name="directory_id" required aria-required="true">
                            <!-- Options will be loaded dynamically -->
                        </select>
                        <small class="form-help" id="directoryInfo">Loading directory information...</small>
                    </div>

                    <div class="form-group">
                        <label for="file">Game File(s) *</label>
                        <input type="file" id="file" name="file" 
                               accept=".nsp,.nsz,.xci"
                               onchange="updateFileInfo()" 
                               multiple
                               required>
                        <small class="form-help">Supported formats: NSP, NSZ, XCI. You can select multiple files to upload sequentially.</small>
                        <div id="fileInfo" class="file-info"></div>
                    </div>
                </div>


                <div class="form-actions">
                    <button type="button" class="btn-cancel" onclick="window.history.back()">
                        Cancel
                    </button>
                    <button type="submit" class="btn-submit">
                        <span id="submitText">üì§ Upload Game</span>
                        <span id="uploadingText" style="display: none;">‚è≥ Uploading...</span>
                    </button>
                </div>
            </form>

            <div id="uploadProgress" class="upload-progress" style="display: none;">
                <div class="upload-queue-info" id="queueInfo">
                    <p class="queue-text" id="queueText">Uploading file 1 of 1</p>
                    <p class="current-file" id="currentFile">Current file: example.nsp</p>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <p class="progress-text" id="progressText">Preparing upload...</p>
                <p class="progress-speed" id="progressSpeed"></p>
            </div>
            
            <div id="uploadResults" class="upload-results" style="display: none;">
                <h4>Upload Results</h4>
                <div id="resultsList"></div>
            </div>
        </div>
    </div>
</div>

<script>
// Upload endpoint from backend configuration (empty means use relative URL)
const UPLOAD_ENDPOINT = "{{ upload_endpoint }}";

// Load directories on page load
document.addEventListener('DOMContentLoaded', async function() {
    await loadDirectories();
    
    // Add event listener for directory selection changes
    const directorySelect = document.getElementById('directory_id');
    directorySelect.addEventListener('change', function() {
        updateStorageInfo(this.options[this.selectedIndex]);
    });
});

async function loadDirectories() {
    const directorySelect = document.getElementById('directory_id');
    const directoryInfo = document.getElementById('directoryInfo');
    
    try {
        const response = await fetch('/uploadercp/directories');
        const data = await response.json();
        
        if (data.success) {
            // Clear existing options
            directorySelect.innerHTML = '';
            
            // Add default directory as first option if it exists
            if (data.default_dir_info && data.default_dir_info.free_gb !== undefined) {
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = `${data.default_upload_dir} (${data.default_dir_info.free_gb} GB available)`;
                defaultOption.dataset.totalGb = data.default_dir_info.total_gb;
                defaultOption.dataset.freeGb = data.default_dir_info.free_gb;
                defaultOption.dataset.usedGb = data.default_dir_info.used_gb;
                directorySelect.appendChild(defaultOption);
            }
            
            // Add other directories to select
            if (data.directories && data.directories.length > 0) {
                data.directories.forEach(dir => {
                    const option = document.createElement('option');
                    option.value = dir._key;
                    option.textContent = `${dir.path} (${dir.free_gb} GB available)`;
                    option.dataset.totalGb = dir.total_gb;
                    option.dataset.freeGb = dir.free_gb;
                    option.dataset.usedGb = dir.used_gb;
                    directorySelect.appendChild(option);
                });
            }
            
            // If no directories available, show error
            if (directorySelect.options.length === 0) {
                directoryInfo.innerHTML = '<strong>No upload directories available. Please contact administrator.</strong>';
                directoryInfo.classList.add('error-message');
                directorySelect.disabled = true;
                return;
            }
            
            // Select first option and show its info
            directorySelect.selectedIndex = 0;
            updateStorageInfo(directorySelect.options[0]);
        } else {
            directoryInfo.innerHTML = '<strong>Failed to load directories. Please refresh the page.</strong>';
            directoryInfo.classList.add('error-message');
            directorySelect.disabled = true;
        }
    } catch (error) {
        console.error('Error loading directories:', error);
        directoryInfo.innerHTML = '<strong>Error loading directories. Please refresh the page.</strong>';
        directoryInfo.classList.add('error-message');
        directorySelect.disabled = true;
    }
}

function updateStorageInfo(option) {
    const directoryInfo = document.getElementById('directoryInfo');
    const freeGb = parseFloat(option.dataset.freeGb) || 0;
    const totalGb = parseFloat(option.dataset.totalGb) || 0;
    const usedGb = parseFloat(option.dataset.usedGb) || 0;
    const percentUsed = totalGb > 0 ? Math.round((usedGb / totalGb) * 100) : 0;
    
    directoryInfo.innerHTML = `
        <strong>Storage:</strong> ${freeGb} GB available of ${totalGb} GB total 
        (${percentUsed}% used)
    `;
}

function updateFileInfo() {
    const fileInput = document.getElementById('file');
    const fileInfo = document.getElementById('fileInfo');
    
    if (fileInput.files.length > 0) {
        let totalSize = 0;
        let fileList = '<strong>Selected Files:</strong><br>';
        
        for (let i = 0; i < fileInput.files.length; i++) {
            const file = fileInput.files[i];
            totalSize += file.size;
            const sizeGB = (file.size / (1024 * 1024 * 1024)).toFixed(2);
            fileList += `${i + 1}. ${file.name} (${sizeGB} GB)<br>`;
        }
        
        const totalSizeGB = (totalSize / (1024 * 1024 * 1024)).toFixed(2);
        const totalSizeMB = (totalSize / (1024 * 1024)).toFixed(2);
        
        fileInfo.innerHTML = `
            ${fileList}
            <strong>Total Size:</strong> ${totalSizeGB} GB (${totalSizeMB} MB)<br>
            <strong>Files to Upload:</strong> ${fileInput.files.length}
        `;
        fileInfo.style.display = 'block';
    } else {
        fileInfo.style.display = 'none';
    }
}

document.getElementById('uploadForm').addEventListener('submit', async function(e) {
    e.preventDefault();
    
    const submitBtn = e.target.querySelector('.btn-submit');
    const submitText = document.getElementById('submitText');
    const uploadingText = document.getElementById('uploadingText');
    const progressDiv = document.getElementById('uploadProgress');
    const progressFill = document.getElementById('progressFill');
    const progressText = document.getElementById('progressText');
    const progressSpeed = document.getElementById('progressSpeed');
    const queueText = document.getElementById('queueText');
    const currentFileText = document.getElementById('currentFile');
    const uploadResults = document.getElementById('uploadResults');
    const resultsList = document.getElementById('resultsList');
    
    const fileInput = document.getElementById('file');
    const files = fileInput.files;
    
    if (files.length === 0) {
        Toast.error('Please select at least one file');
        return;
    }
    
    // Disable submit button
    submitBtn.disabled = true;
    submitText.style.display = 'none';
    uploadingText.style.display = 'inline';
    progressDiv.style.display = 'block';
    uploadResults.style.display = 'none';
    resultsList.innerHTML = '';
    
    const uploadResultsData = [];
    
    // Upload files sequentially
    for (let i = 0; i < files.length; i++) {
        const file = files[i];
        
        // Update queue info
        queueText.textContent = `Uploading file ${i + 1} of ${files.length}`;
        currentFileText.textContent = `Current file: ${file.name}`;
        
        // Reset progress bar
        progressFill.style.width = '0%';
        progressText.textContent = 'Preparing upload...';
        progressSpeed.textContent = '';
        
        try {
            const result = await uploadSingleFile(file, progressFill, progressText, progressSpeed);
            uploadResultsData.push({
                filename: file.name,
                success: result.success,
                message: result.message,
                error: result.error
            });
            
            // Add result to list
            const resultItem = document.createElement('div');
            resultItem.className = result.success ? 'result-item result-success' : 'result-item result-error';
            resultItem.innerHTML = `
                <span class="result-icon">${result.success ? '‚úì' : '‚úó'}</span>
                <span class="result-filename">${file.name}</span>
                <span class="result-message">${result.success ? result.message : result.error}</span>
            `;
            resultsList.appendChild(resultItem);
            uploadResults.style.display = 'block';
            
            if (result.success) {
                Toast.success(`${file.name} uploaded successfully!`);
            } else {
                Toast.error(`Failed to upload ${file.name}: ${result.error}`);
            }
        } catch (error) {
            uploadResultsData.push({
                filename: file.name,
                success: false,
                error: error.message || 'Upload failed'
            });
            
            const resultItem = document.createElement('div');
            resultItem.className = 'result-item result-error';
            resultItem.innerHTML = `
                <span class="result-icon">‚úó</span>
                <span class="result-filename">${file.name}</span>
                <span class="result-message">${error.message || 'Upload failed'}</span>
            `;
            resultsList.appendChild(resultItem);
            uploadResults.style.display = 'block';
            
            Toast.error(`Failed to upload ${file.name}: ${error.message}`);
        }
    }
    
    // All uploads complete
    progressDiv.style.display = 'none';
    submitBtn.disabled = false;
    submitText.style.display = 'inline';
    uploadingText.style.display = 'none';
    
    // Show summary
    const successCount = uploadResultsData.filter(r => r.success).length;
    const failCount = uploadResultsData.length - successCount;
    
    if (successCount === files.length) {
        Toast.success(`All ${files.length} file(s) uploaded successfully!`);
        setTimeout(() => {
            window.location.href = '/uploadercp';
        }, 2000);
    } else if (successCount > 0) {
        Toast.warning(`${successCount} file(s) uploaded, ${failCount} failed`);
    } else {
        Toast.error(`All uploads failed`);
    }
});

async function uploadSingleFile(file, progressFill, progressText, progressSpeed) {
    return new Promise((resolve, reject) => {
        const formData = new FormData();
        
        // Get form values
        const type = document.getElementById('type').value;
        const directoryId = document.getElementById('directory_id').value;
        
        formData.append('type', type);
        if (directoryId) {
            formData.append('directory_id', directoryId);
        }
        formData.append('file', file);
        
        const xhr = new XMLHttpRequest();
        
        let startTime = Date.now();
        let lastLoaded = 0;
        let lastTime = startTime;
        
        xhr.upload.addEventListener('progress', function(event) {
            if (event.lengthComputable) {
                const percentComplete = Math.round((event.loaded / event.total) * 100);
                progressFill.style.width = percentComplete + '%';
                progressText.textContent = `Uploading: ${percentComplete}%`;
                
                // Calculate upload speed
                const currentTime = Date.now();
                const timeDiff = (currentTime - lastTime) / 1000; // seconds
                const loadedDiff = event.loaded - lastLoaded;
                
                if (timeDiff > 0.5) { // Update speed every 0.5 seconds
                    const speedBps = loadedDiff / timeDiff;
                    const speedMBps = speedBps / (1024 * 1024);
                    
                    // Format size
                    const uploadedMB = (event.loaded / (1024 * 1024)).toFixed(2);
                    const totalMB = (event.total / (1024 * 1024)).toFixed(2);
                    
                    progressSpeed.textContent = `${uploadedMB} MB / ${totalMB} MB (${speedMBps.toFixed(2)} MB/s)`;
                    
                    lastLoaded = event.loaded;
                    lastTime = currentTime;
                }
            }
        });
        
        xhr.addEventListener('load', function() {
            if (xhr.status >= 200 && xhr.status < 300) {
                try {
                    const data = JSON.parse(xhr.responseText);
                    
                    if (data.success) {
                        resolve({
                            success: true,
                            message: data.message || 'Upload successful'
                        });
                    } else {
                        resolve({
                            success: false,
                            error: data.error || 'Upload failed'
                        });
                    }
                } catch (error) {
                    resolve({
                        success: false,
                        error: 'Failed to parse server response'
                    });
                }
            } else {
                resolve({
                    success: false,
                    error: `Upload failed with status: ${xhr.status} & json.error: ${xhr.responseText}`
                });
            }
        });
        
        xhr.addEventListener('error', function() {
            resolve({
                success: false,
                error: 'Network error occurred during upload'
            });
        });
        
        xhr.addEventListener('abort', function() {
            resolve({
                success: false,
                error: 'Upload was cancelled'
            });
        });
        
        // Use relative URL if UPLOAD_ENDPOINT is empty, otherwise prepend it
        const uploadUrl = UPLOAD_ENDPOINT ? UPLOAD_ENDPOINT + '/uploadercp/upload' : '/uploadercp/upload';
        
        xhr.open('POST', uploadUrl);
        xhr.send(formData);
    });
}
</script>

<style>
.upload-page {
    max-width: 800px;
    margin: 40px auto;
    padding: 20px;
}

.page-header {
    text-align: center;
    margin-bottom: 40px;
}

.page-header h2 {
    color: #fff;
    font-size: 36px;
    margin-bottom: 10px;
}

.page-subtitle {
    color: #999;
    font-size: 18px;
}

.alternative-upload {
    margin-top: 20px;
    text-align: center;
}

.btn-alt-upload {
    display: inline-block;
    padding: 12px 24px;
    background: linear-gradient(135deg, #10b981, #059669);
    color: #fff;
    text-decoration: none;
    border-radius: 8px;
    font-weight: 600;
    font-size: 14px;
    transition: all 0.2s;
    box-shadow: 0 2px 4px rgba(16, 185, 129, 0.3);
}

.btn-alt-upload:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(16, 185, 129, 0.5);
}

.alt-upload-help {
    display: block;
    margin-top: 8px;
    color: #888;
    font-size: 12px;
}

.upload-form-container {
    background: #2a2a2a;
    border-radius: 12px;
    padding: 30px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
}

.form-section {
    margin-bottom: 30px;
    padding-bottom: 30px;
    border-bottom: 1px solid #333;
}

.form-section:last-of-type {
    border-bottom: none;
}

.form-section h3 {
    color: #fff;
    font-size: 20px;
    margin-bottom: 20px;
}

.form-group {
    margin-bottom: 20px;
}

.form-group label {
    display: block;
    color: #ccc;
    font-weight: 600;
    margin-bottom: 8px;
}

.form-group input[type="text"],
.form-group input[type="url"],
.form-group input[type="number"],
.form-group input[type="date"],
.form-group select,
.form-group textarea {
    width: 100%;
    padding: 12px;
    background: #1a1a1a;
    border: 1px solid #444;
    border-radius: 6px;
    color: #fff;
    font-size: 14px;
}

.form-group input[type="file"] {
    width: 100%;
    padding: 10px;
    background: #1a1a1a;
    border: 2px dashed #444;
    border-radius: 6px;
    color: #999;
    cursor: pointer;
}

.form-group input[type="file"]:hover {
    border-color: #5a9fd4;
}

.form-group textarea {
    resize: vertical;
    min-height: 80px;
}

.form-help {
    display: block;
    color: #999;
    font-size: 12px;
    margin-top: 5px;
}

.form-help.error-message {
    color: #ef4444;
}

.file-info {
    margin-top: 10px;
    padding: 10px;
    background: #1a1a1a;
    border-radius: 6px;
    color: #5a9fd4;
    font-size: 13px;
    display: none;
}

.form-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
}

.form-actions {
    display: flex;
    gap: 15px;
    justify-content: flex-end;
    margin-top: 30px;
}

.btn-cancel, .btn-submit {
    padding: 12px 30px;
    border: none;
    border-radius: 6px;
    font-weight: 600;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.2s;
}

.btn-cancel {
    background: #444;
    color: #fff;
}

.btn-cancel:hover {
    background: #555;
}

.btn-submit {
    background: linear-gradient(135deg, #5a9fd4, #4a7fb4);
    color: #fff;
}

.btn-submit:hover:not(:disabled) {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(90, 159, 212, 0.4);
}

.btn-submit:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.upload-progress {
    margin-top: 20px;
    padding: 20px;
    background: #1a1a1a;
    border-radius: 8px;
}

.upload-queue-info {
    margin-bottom: 15px;
}

.queue-text {
    color: #5a9fd4;
    font-weight: 600;
    font-size: 14px;
    margin: 0 0 5px 0;
}

.current-file {
    color: #999;
    font-size: 13px;
    margin: 0;
    font-style: italic;
}

.progress-bar {
    width: 100%;
    height: 20px;
    background: #333;
    border-radius: 10px;
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(135deg, #5a9fd4, #4a7fb4);
    width: 0%;
    transition: width 0.3s;
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

.progress-text {
    color: #5a9fd4;
    text-align: center;
    margin-top: 10px;
    font-weight: 600;
}

.progress-speed {
    color: #999;
    text-align: center;
    margin-top: 5px;
    font-size: 13px;
}

.upload-results {
    margin-top: 20px;
    padding: 20px;
    background: #1a1a1a;
    border-radius: 8px;
}

.upload-results h4 {
    color: #fff;
    margin-top: 0;
    margin-bottom: 15px;
    font-size: 16px;
}

.result-item {
    padding: 12px;
    margin-bottom: 10px;
    border-radius: 6px;
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 13px;
}

.result-item:last-child {
    margin-bottom: 0;
}

.result-success {
    background: rgba(45, 122, 75, 0.2);
    border: 1px solid rgba(45, 122, 75, 0.4);
}

.result-error {
    background: rgba(239, 68, 68, 0.2);
    border: 1px solid rgba(239, 68, 68, 0.4);
}

.result-icon {
    font-size: 16px;
    font-weight: bold;
}

.result-success .result-icon {
    color: #10b981;
}

.result-error .result-icon {
    color: #ef4444;
}

.result-filename {
    color: #fff;
    font-weight: 600;
    flex: 0 0 auto;
    max-width: 40%;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.result-message {
    color: #999;
    flex: 1;
}

@media (max-width: 768px) {
    .form-row {
        grid-template-columns: 1fr;
    }
}
</style>

<script src="{{ url_for('static', path='js/custom-dropdown.js') }}"></script>
{% endblock %}
